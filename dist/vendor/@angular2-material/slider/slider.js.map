{"version":3,"file":"slider.js","sourceRoot":"","sources":["../../Volumes/Data/Projects/material2/tmp/broccoli_type_script_compiler-input_base_path-MGzNSvmZ.tmp/0/src/demo-app/components/slider/slider.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Component,\n  ElementRef,\n  HostBinding,\n  Input,\n  ViewEncapsulation,\n  AfterContentInit,\n} from '@angular/core';\nimport {BooleanFieldValue} from '@angular2-material/core/annotations/field-value';\nimport {applyCssTransform} from '@angular2-material/core/style/apply-transform';\n\n@Component({\n  moduleId: module.id,\n  selector: 'md-slider',\n  host: {\n    'tabindex': '0',\n    '(click)': 'onClick($event)',\n    '(slide)': 'onSlide($event)',\n    '(slidestart)': 'onSlideStart($event)',\n    '(slideend)': 'onSlideEnd()',\n    '(window:resize)': 'onResize()',\n    '(blur)': 'onBlur()',\n  },\n  templateUrl: 'slider.html',\n  styleUrls: ['slider.css'],\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MdSlider implements AfterContentInit {\n  /** A renderer to handle updating the slider's thumb and fill track. */\n  private _renderer: SliderRenderer = null;\n\n  /** The dimensions of the slider. */\n  private _sliderDimensions: ClientRect = null;\n\n  @Input()\n  @BooleanFieldValue()\n  @HostBinding('class.md-slider-disabled')\n  @HostBinding('attr.aria-disabled')\n  disabled: boolean = false;\n\n  /** The miniumum value that the slider can have. */\n  private _min: number = 0;\n\n  /** The maximum value that the slider can have. */\n  private _max: number = 100;\n\n  /** The percentage of the slider that coincides with the value. */\n  private _percent: number = 0;\n\n  /** The values at which the thumb will snap. */\n  @Input() step: number = 1;\n\n  /**\n   * Whether or not the thumb is sliding.\n   * Used to determine if there should be a transition for the thumb and fill track.\n   * TODO: internal\n   */\n  isSliding: boolean = false;\n\n  /**\n   * Whether or not the slider is active (clicked or sliding).\n   * Used to shrink and grow the thumb as according to the Material Design spec.\n   * TODO: internal\n   */\n  isActive: boolean = false;\n\n  /** Indicator for if the value has been set or not. */\n  private _isInitialized: boolean = false;\n\n  /** Value of the slider. */\n  private _value: number = 0;\n\n  @Input()\n  @HostBinding('attr.aria-valuemin')\n  get min() {\n    return this._min;\n  }\n\n  set min(v: number) {\n    // This has to be forced as a number to handle the math later.\n    this._min = Number(v);\n\n    // If the value wasn't explicitly set by the user, set it to the min.\n    if (!this._isInitialized) {\n      this.value = this._min;\n    }\n  }\n\n  @Input()\n  @HostBinding('attr.aria-valuemax')\n  get max() {\n    return this._max;\n  }\n\n  set max(v: number) {\n    this._max = Number(v);\n  }\n\n  @Input()\n  @HostBinding('attr.aria-valuenow')\n  get value() {\n    return this._value;\n  }\n\n  set value(v: number) {\n    this._value = Number(v);\n    this._isInitialized = true;\n  }\n\n  constructor(elementRef: ElementRef) {\n    this._renderer = new SliderRenderer(elementRef);\n  }\n\n  /**\n   * Once the slider has rendered, grab the dimensions and update the position of the thumb and\n   * fill track.\n   * TODO: internal\n   */\n  ngAfterContentInit() {\n    this._sliderDimensions = this._renderer.getSliderDimensions();\n    this.snapToValue();\n  }\n\n  /** TODO: internal */\n  onClick(event: MouseEvent) {\n    if (this.disabled) {\n      return;\n    }\n\n    this.isActive = true;\n    this.isSliding = false;\n    this._renderer.addFocus();\n    this.updateValueFromPosition(event.clientX);\n    this.snapToValue();\n  }\n\n  /** TODO: internal */\n  onSlide(event: HammerInput) {\n    if (this.disabled) {\n      return;\n    }\n\n    // Prevent the slide from selecting anything else.\n    event.preventDefault();\n    this.updateValueFromPosition(event.center.x);\n  }\n\n  /** TODO: internal */\n  onSlideStart(event: HammerInput) {\n    if (this.disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    this.isSliding = true;\n    this.isActive = true;\n    this._renderer.addFocus();\n    this.updateValueFromPosition(event.center.x);\n  }\n\n  /** TODO: internal */\n  onSlideEnd() {\n    this.isSliding = false;\n      this.snapToValue();\n  }\n\n  /** TODO: internal */\n  onResize() {\n    this.isSliding = true;\n    this._sliderDimensions = this._renderer.getSliderDimensions();\n    // Skip updating the value and position as there is no new placement.\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /** TODO: internal */\n  onBlur() {\n    this.isActive = false;\n  }\n\n  /**\n   * When the value changes without a physical position, the percentage needs to be recalculated\n   * independent of the physical location.\n   * This is also used to move the thumb to a snapped value once sliding is done.\n   */\n  updatePercentFromValue() {\n    this._percent = (this.value - this.min) / (this.max - this.min);\n  }\n\n  /**\n   * Calculate the new value from the new physical location. The value will always be snapped.\n   */\n  updateValueFromPosition(pos: number) {\n    let offset = this._sliderDimensions.left;\n    let size = this._sliderDimensions.width;\n\n    // The exact value is calculated from the event and used to find the closest snap value.\n    this._percent = this.clamp((pos - offset) / size);\n    let exactValue = this.min + (this._percent * (this.max - this.min));\n\n    // This calculation finds the closest step by finding the closest whole number divisible by the\n    // step relative to the min.\n    let closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\n    // The value needs to snap to the min and max.\n    this.value = this.clamp(closestValue, this.min, this.max);\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /**\n   * Snaps the thumb to the current value.\n   * Called after a click or drag event is over.\n   */\n  snapToValue() {\n    this.updatePercentFromValue();\n    this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n  }\n\n  /**\n   * Return a number between two numbers.\n   */\n  clamp(value: number, min = 0, max = 1) {\n    return Math.max(min, Math.min(value, max));\n  }\n}\n\n/**\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\n */\nexport class SliderRenderer {\n  private _sliderElement: HTMLElement;\n\n  constructor(elementRef: ElementRef) {\n    this._sliderElement = elementRef.nativeElement;\n  }\n\n  /**\n   * Get the bounding client rect of the slider track element.\n   * The track is used rather than the native element to ignore the extra space that the thumb can\n   * take up.\n   */\n  getSliderDimensions() {\n    let trackElement = this._sliderElement.querySelector('.md-slider-track');\n    return trackElement.getBoundingClientRect();\n  }\n\n  /**\n   * Update the physical position of the thumb and fill track on the slider.\n   */\n  updateThumbAndFillPosition(percent: number, width: number) {\n    // A container element that is used to avoid overwriting the transform on the thumb itself.\n    let thumbPositionElement =\n        <HTMLElement>this._sliderElement.querySelector('.md-slider-thumb-position');\n    let fillTrackElement = <HTMLElement>this._sliderElement.querySelector('.md-slider-track-fill');\n\n    let position = percent * width;\n\n    fillTrackElement.style.width = `${position}px`;\n    applyCssTransform(thumbPositionElement, `translateX(${position}px)`);\n  }\n\n  /**\n   * Focuses the native element.\n   * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n   */\n  addFocus() {\n    this._sliderElement.focus();\n  }\n}\n\nexport const MD_SLIDER_DIRECTIVES = [MdSlider];\n"]}