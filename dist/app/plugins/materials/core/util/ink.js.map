{"version":3,"file":"ink.js","sourceRoot":"","sources":["../../../../../Volumes/Data/OElite/cosmos/public/OEme/tmp/broccoli_type_script_compiler-input_base_path-7nMsUUjz.tmp/0/src/app/plugins/materials/core/util/ink.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Created by mleader1 on 01/07/2016.\n */\nimport {Animate} from \"./animate\";\n\n/**\n * Create ink ripples on elements in the page.\n */\nexport abstract class Ink {\n\n    /**\n     * Determine if ink can be applied to a given element.\n     * @param element The element to check\n     */\n    static canApply(element:HTMLElement):boolean {\n        return !element.hasAttribute('md-no-ink');\n    }\n\n    /**\n     * Ink ripples are equal in height/width, so get the scalar size\n     * of the container.\n     *\n     * @param fit To fit the ripple to the element\n     * @param width Width of the ripple container\n     * @param height Height of the ripple container\n     * @returns {number}\n     */\n    static getSize(fit:boolean, width:number, height:number) {\n        return fit\n            ? Math.max(width, height)\n            : Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n    }\n\n    /**\n     * Apply an ink ripple to an element at the given position.\n     *\n     * @param element The element to apply a ripple to\n     * @param left The x position inside the element for the ripple to originate from\n     * @param top The y position inside the element for the ripple to originate from\n     * @returns {Promise<any>} A promise that resolves when the ripple has faded\n     */\n    static ripple(element:HTMLElement, left:number, top:number):Promise<any> {\n        let fit:boolean = !!element.getAttribute('md-fab');\n\n        let container = element.querySelector('.md-ripple-container');\n        if (!container) {\n            container = document.createElement('div');\n            container.classList.add('md-ripple-container');\n            element.appendChild(container);\n        }\n\n        let ripple = document.createElement('div');\n        ripple.classList.add('md-ripple');\n\n        let getInitialStyles = ():any => {\n            let color = window.getComputedStyle(element).color || 'rgb(0,0,0)';\n            let size = Ink.getSize(fit, element.clientWidth, element.clientHeight);\n            return {\n                'background-color': color,\n                left: `${left}px`,\n                top: `${top}px`,\n                width: `${size}px`,\n                height: `${size}px`\n            };\n        };\n\n        return Animate.setStyles(ripple, getInitialStyles())\n            .then(() => container.appendChild(ripple))\n            .then(() => ripple.classList.add('md-ripple-placed'))\n            .then(() => Animate.wait())\n            .then(() => ripple.classList.add('md-ripple-scaled'))\n            .then(() => ripple.classList.add('md-ripple-active'))\n            .then(() => Animate.wait(450))\n            .then(() => ripple.classList.remove('md-ripple-active'))\n            .then(() => Animate.wait(650))\n            .then(() => container.removeChild(ripple));\n    }\n\n    /**\n     * Start an ink ripple from a MouseEvent.\n     *\n     * @param element The element to ripple on.\n     * @param event The mouse event to indicate where the ripple should start at\n     * @returns {Promise<any>} A promise that resolves when the ripple has faded.\n     */\n    static rippleEvent(element:HTMLElement, event:MouseEvent):Promise<any> {\n        let rippleX = event.offsetX;\n        let rippleY = event.offsetY;\n        if (element !== event.srcElement) {\n            const rect = element.getBoundingClientRect();\n            rippleX = event.clientX - rect.left;\n            rippleY = event.clientY - rect.top;\n        }\n        return Ink.ripple(element, rippleX, rippleY);\n    }\n\n}"]}